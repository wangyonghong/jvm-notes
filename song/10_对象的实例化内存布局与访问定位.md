# 10_对象的实例化内存布局与访问定位

## 1 - 对象的实例化

### 创建对象的方式

- new 关键字，这是最常见的方式
  - 变形1：Xxx 的静态方法
  - 变形2：XxxBuilder / XxxFactory 的静态方法
- Class 的 newInstance()（过时，不推荐）：反射的方式，只能调用空参的构造器，权限必须是 public
- Constructor 的 newInstance(xxx)：反射的方式，可以调用空参、带参的构造器，权限没有要求
- 使用 clone() ：不调用任何构造器，当前类需要实现 Cloneable 接口，实现 clone()
- 使用反序列化：从文件中、从网络中获取一个对象的二进制流
- 第三方库 Objenesis

### 创建对象的步骤

**1.判断对象对应的类是否加载、链接、初始化**

虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名 + 类名 为 key 进行查找对用的 .class 文件。如果没有找到文件，则抛出 ClassNotFoundException 异常，如果找到，则进行类加载，并生成对应的 Class 类对象。

**2.为对象分配内存**

首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。

如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小。

- 如果内存规整，使用指针碰撞。如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Pointer）来为对象分配内存。意思是所有用过的内存放在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial、ParNew 这种基于压缩算法的，虚拟机采用这种分配方式，一般使用带 compact （整理）过程的收集器时，使用指针碰撞。
- 如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配。如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，在分配的时候就从列表中找到一块足够大的空间划分给实例对象，并更新列表上的内存。这种分配方式称为“空闲列表（Free List）”

说明：选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

**3.处理并发安全问题**

在分配内存空间时，另外一个问题是及时保证 new 对象时候的线程安全性；创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：

- CAS（Compare And Swap）失败重试、区域加锁：保证指针更新操作的原子性
- TLAB（Thread Local Allocation Buffer）把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲区。虚拟机是否使用 TLAB，可以通过 `-XX:+/-UseTLAB` 参数来设定。

**4.初始化分配到的空间**

内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在 Java 代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

**5.设置对象的对象头**

将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。

**6.执行 init 方法进行初始化**

在 Java 程序的视角来看，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。

因此，一般来说，new 指令之后会接着就是执行方法（由字节码中是否跟随有 invokespecial 指令所决定），把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。

## 2 - 对象的内存布局

1.对象头（Header）

- 运行时元数据（Mark Word）：
  - 哈希值（HashCode）
  - GC 分代年龄
  - 锁状态标志
  - 线程持有的锁
  - 偏向线程 ID
  - 偏向时间戳
- 类型指针：指向类元数据 InstanceKlass，确定该对象所属的类型

说明：如果是数组，还需记录数组的长度。

2.实例数据（Instance Data）

说明：它是对象真正存储的有效信息，包括程序代码中定义的各种数据类型的字段（包括从父类继承下来的和本身拥有的字段）

规则：

- 相同宽度的字段总是被分配在一起
- 父类中定义的变量会出现在子类之前
- 如果 CompactFields 参数为 true（默认为 true）：子类的窄变量可能插入到父类变量的空隙

3.对齐填充（Padding）

不是必须的，也没有特别含义，仅仅起到占位符的作用

图解：

![26-11-53-wR6H77-nKVMmW](https://up-img.yonghong.tech/pic/2020/11/26-11-54-26-11-53-wR6H77-nKVMmW-rpZKYq.png)





## 3 - 对象的访问定位

创建对象的目的就是为了使用它。

对象访问的两种方式：

- 句柄访问
  - 优点：reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改。
- 直接指针（HotSpot 使用）
  - 优点：省了一步定位操作

